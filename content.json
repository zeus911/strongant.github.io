[{"title":"SpringBoot学习一","date":"2017-03-12T15:42:17.000Z","path":"2017/03/12/SpringBoot学习1-md/","text":"SpringBoot Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 遵循建立生产就绪Spring应用程序的观点。SpringBoot支持约定优于配置的惯例，旨在让您尽快启动和运行。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. SpringBoot可以轻松的创建单独的，生产级的基于Spring的应用，您可以“直接运行”。我们为Spring平台和第三方库提供了开箱即用的设置，这样你就可以有条不斋的开始。大多数的SpringBoot程序只需要很少的Spring配置。 Features Create stand-alone Spring applications Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) Provide opinionated ‘starter’ POMs to simplify your Maven configuration Automatically configure Spring whenever possible Provide production-ready features such as metrics, health checks and externalized configuration Absolutely no code generation and no requirement for XML configuration 功能 创建标准独立的Spring应用程序 直接嵌入Tomcat、Jetty或者Undertow（不需要部署WAR文件） 提供建议的‘starter’POM模板以简化您的Maven配置 每当可能时自动配置Spring 提供生产就绪的功能，如指标，运行状况检查和外部化配置 绝对没有代码生成和不需要XML配置 The reference guide includes detailed descriptions of all the features, plus an extensive howto for common use cases.该参考指南包含所有功能的详细说明，以及广泛的如何使用共同使用情况。 Quick StartIf you are Java developer you can use start.spring.io to generate a basic project, follow the “Quick Start” example below, or read the reference documentation getting started guide. 快速开始如果你是一名Java程序员，你可以通过start.spring.io生成基本项目，按照下面的“快速开始”示例或者阅读参考文档的入门指南。 The recommended way to get started using spring-boot in your project is with a dependency management system – the snippet below can be copied and pasted into your build. Need help? See our getting started guides on building with Maven and Gradle. spring-boot在项目中开始使用的推荐方法是使用依赖关系管理系统 - 下面的代码段可以复制并粘贴到您的构建中。需要帮忙？请参阅我们使用Maven和 Gradle构建的入门指南。 Maven1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle123dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.1.RELEASE&quot;)&#125; 1hello/SampleController.java 123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping(&quot;/&quot;) @ResponseBody String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; Spring Boot CLISpring Boot ships with a command line tool that can be used if you want to quickly prototype with Spring. It allows you to run Groovy scripts, which means that you have a familiar Java-like syntax, without so much boilerplate code. Follow the instructions in our main documentation if you want to install the Spring Boot CLI. Spring Boot 命令行工具Spring Boot附带一个命令行工具，如果你想快速使用Spring原型，可以使用它。它允许你运行Groovy脚本，这意味着你有一个熟悉的类似Java的语法，没有那么多的样板代码。如果要安装Spring Boot CLI，请按照我们的主要文档中的说明进行操作。","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://baiwenhui.com/tags/SpringBoot/"}]},{"title":"Java面试(一)","date":"2017-03-04T16:04:28.000Z","path":"2017/03/04/Java面试-一/","text":"Java基础抽象类和接口的区别？ 抽象类中可以包含抽象方法和非抽象方法，接口只能包含公开的抽象方法； 抽象类中的变量是各种类型的，而接口只能包含public abstract final 类型； 接口中不能含有静态代码块和静态方法，而抽象类中可以包含； 一个类只能继承一个抽象类，但是可以实现多个接口； 抽象类可以有构造方法，接口不能有； HashMap和HashTable的区别？ HashTable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现 从方法上看，HashMap去掉了HashTable的contains方法 HashTable是同步的（线程安全），而HashMap是线程不安全的，效率上HashMap更快 HashMap允许空键值，HashTable不允许，可以查看HashTable的实现源码： 12345678910111213141516171819202122232425...public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;... HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。而Hashtable返回的Enumeration不是快速失败的。 Java中如何创建一个新线程？ 实现runable接口并重写run方法； 继承Thread类重写run方法； 实现Callable接口，重写call()方法；使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值；使用FutureTask对象作为Thread对象的target创建并启动线程，调用FutureTask对象的get()方法获得子线程执行结束后的返回值； 什么是AIDL？ AIDL全称Android Interface Definition Language（AndRoid接口描述语言）是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的.AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。 AIDL支持的数据类型有Stirng，list，map，All native java datatype 求计算1-2+3-4+5-6…的方法，n很大，考虑性能？1234567891011121314151617181920212223public static long fn(long n) &#123; if(n&lt;=0) &#123; //1-2+3-4+5-6 当n为负数时，结果肯定为负数,使用加法结合律得出当n为偶数时,结果为(1-2)+(3-4)...(-1)+(-1),规律 //当n为2时，结果为一个-1和，当n为4时，结果为2个-1的和,由此得出此结果的规律为(-1)*(n/2) //当n为奇数的时候，当n为1时，结果为1，当n为3时候,结果为2,当n为5时候,结果为3... //由此得出规律应该为：(-1)*(n/2)+n =-n/2+n 或者 (n+1)/2 //&gt;&gt;(右移) //操作数每右移一位，相当于该数除以2 System.out.println(&quot;error&quot;); return 0; &#125; if(0==n%2) return (n&gt;&gt;1)*(-1); else&#123; System.out.println(&quot;aaa&quot;); return (n&gt;&gt;1)*(-1)+n; //或者可以替换为(n+1)&gt;&gt;1; &#125; &#125; char类型的取值范围：0-216-1 Java中如何在线程中返回一个值？答案：可以让这个类去实现Callable接口，然后定义私有变量进行传递即可：如，1234567891011121314151617181920212223package com.pff;import java.util.concurrent.Callable;/** * Created by strongant on 16-6-16. */public class MutiThread implements Callable&lt;String&gt; &#123; private String str; private int count = 1; public MutiThread(String str) &#123; this.str = str; &#125; //需要实现的CallAble的Call方法 public String call() throws Exception &#123; for (int i = 0; i &lt; this.count; i++) &#123; System.out.println(&quot;Callable的call()方法打印:&quot; + this.str + &quot; &quot; + i); &#125; return this.str; &#125;&#125; 测试调用1234567891011121314151617181920212223242526272829303132package com.pff;import java.util.ArrayList;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by strongant on 16-6-16. */public class CallableTest &#123; public static void main(String[] args) &#123; //创建一个线程池 ExecutorService exs = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; al = new ArrayList&lt;&gt;(); al.add(exs.submit(new MutiThread(&quot;String0&quot;))); for (Future&lt;String&gt; fs : al) &#123; try &#123; System.out.println(fs.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; exs.shutdown(); /*第二种方式，使用FutureTask来接收线程的返回值 MutiThread task = new MutiThread(&quot;test&quot;); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task); Thread thread = new Thread(futureTask); thread.start(); */ &#125;&#125; 具体流程就是实现Callable 泛型接口，然后线程类定义私有变量，重写call()方法，并且返回Callable接口声明的泛型类型值即可； 获取的时候使用Future泛型类去使用Future类的get()方法就可以获取到；","tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://baiwenhui.com/tags/Java面试/"}]},{"title":"2017开工快乐","date":"2017-02-05T13:43:05.000Z","path":"2017/02/05/2017开工快乐/","text":"春节已经结束了，祝愿大家在新的一年多挣钱！在这里给大家分享一份简历模板：http://resume.f-tm.net/ 简历开源地址:https://github.com/googlerobot/resume","tags":[{"name":"随笔","slug":"随笔","permalink":"http://baiwenhui.com/tags/随笔/"}]},{"title":"春节回家","date":"2017-01-23T13:20:53.000Z","path":"2017/01/23/春节回家/","text":"对于刚过去不远的2016年，有欢乐，有辛酸，有失望，有快乐！还记得自己2016年年初的时候计划通过自己的努力买一台MakBook Pro（非正式工资的钱买），可到头来并没有完成我的这个愿望！ 远在他乡的我，随着年龄的增长，感到些许压抑、彷徨和不安，在新的2017年我决定奋力冲刺，早日实现自己的梦想！ 远在他乡，来到陌生的城市，看着天天上涨的房价，买房这件事情也只能想想。自己长大了，父母却老了，他们需要我们的照顾，在一线城市上几年班，攒个首付去二三线城市买一套房子然后打拼事业，这也是我的打算！乘着二三线城市的房价还没有大幅上涨，还是早下手为强！ 在一线城市上班，别人听起来工资很高，经常听到隔壁阿姨说：谁谁家的儿子在哪哪呢，一个月挣1W多呢，可是花销完，房租缴完，也剩不下多少钱了。要想拿到更多的薪水，就得从自身开始做起。我已经为自己制定好了2017年的计划，你呢？ 在这里，提前祝大家新年快乐！以上是我的一点生活感触，博客地址：http://baiwenhui.com，欢迎交流、分享：","tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://baiwenhui.com/tags/生活感悟/"}]},{"title":"rxjs翻译-rxjs介绍","date":"2017-01-22T13:26:40.000Z","path":"2017/01/22/rxjs翻译-rxjs介绍/","text":"介绍RxJS是一个基于可观察对象(Observable)序列，用于异步或者事件编程的库。它提供一个核心类型，Observable ，几个卫星类型（Observer, Schedulers, Subjects）以及一些由Array#extras (map, filter, reduce, every等)激发的，让异步事件可以以集合的方式被处理的运算子(Operators)。 可以将RxJS想象成是用于处理事件的Lodash. ReactiveX将Observer模式和Iterator模式和对集合进行函数式编程结合起来，从而满足了对事件序列进行管理的需求。 RxJS用于解决异步事件的管理问题，它的核心概念如下： Observable: 代表数据与事件的集合，这个集合可以被调用，从而可以生成数据和事件。 Observer: 回调函数的集合，用于获取想要数据。这些数据来自于Observable。 Subscription: 用于表示Observable的执行状态，主要用于执行的取消。 Operator: 函数式风格的纯函数，通过map, filter, concat, flatMap等操作对集合进行处理。 Subject: 与EventEmitter等价，唯一可以将一个值或者事件向个多个Observer进行广播的办法。 Schedulers: 一个中心化的、控制并发的分发器，允许我们可以在象setTimeout、requestAnimationFrame或者其它类似的计算中可以进行调整。 第一个例子通常你是这样注册事件的侦听器(listener)的。12var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log('Clicked!')); 使用RxJS的话，你要创建一个Observable来替换。 123var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .subscribe(() =&gt; console.log('Clicked!')); 纯粹(Purity)让RxJS强大的是它能完全通过函数来生成数值，这也就意味着可以减少代码出错的机会。 通常你会创建比较不纯粹的函数，在这样的函数里，其它的代码片段会让你的状态变的混乱。 123var count = 0;var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log(`Clicked $&#123;++count&#125; times`)); 而使用RxJS可以将你的状态进行隔离。 译者注： 指count不再需要定义在外面。 1234var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 这里scan运算子的工作方式与reduce在数组里的工作方式是一样的。它从传给回调函数的值中获取值。返回的值将会作为下一次的传入值。 译者注：scan第二个参数0是初始值。对于上面的函数来说就可以用来侦听被点击的次数了，非常的方便。 流转（Flow）RxJS有一堆的运算子可以帮助你控制事件如何在你的可观察对象里流转。 下面是你在纯JavaScript下允许一分钟最多一次点击的代码： 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', () =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(`Clicked $&#123;++count&#125; times`); lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 12345var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 其实的流转控制运算子还有filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged等。 值(Values)你可以转化赋给你的观察者的值。 下面是你在纯JavaScript下添加当前鼠标的每个点击事件的x轴位置的代码： 1234567891011var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', (event) =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; count += event.clientX; console.log(count) lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 123456var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .map(event =&gt; event.clientX) .scan((count, clientX) =&gt; count + clientX, 0) .subscribe(count =&gt; console.log(count)); 另外几个用于生成值的运算子有pluck, pairwise,sample等。 译者注：这里map可以将事件里的值取出来，如果不进行map，clientX里的值就是事件本身。这里要注意的是每次变换，其实对象是发生变化的。subscribe一次之后就不能再subscribe了。","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://baiwenhui.com/tags/rxjs/"}]},{"title":"修正browser-sync公众号文章的错误","date":"2017-01-21T14:30:29.000Z","path":"2017/01/21/修正browser-sync公众号文章的错误/","text":"首先说说声对不起，在上一篇的公众号文章：《放弃F5，拥抱browser-sync》中存在几个错误点。链接地址: https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 几个错误点修改如下： 文章中的：……更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试…将“进项调试”修改为“进行调试”2. 最后的代码有一个目录错误，因为我的粗心，给大家带来的不变，请见谅！在以后的文章中我会更加小心发表文章，力求保证没有错误！1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 修改为：1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;.app/dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;.app/dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 参照对比原文地址： https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 目前内容已经修改！欢迎反馈，欢迎交流：","tags":[]},{"title":"hexo搭建成功","date":"2017-01-19T15:20:52.000Z","path":"2017/01/19/hexo搭建成功/","text":"终于折腾完了，搭建好我的hexo，的确挺方便的！感谢前人的贡献！","tags":[]}]