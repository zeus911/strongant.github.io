[{"title":"Hello World","date":"2017-01-22T13:32:14.346Z","path":"2017/01/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"rxjs翻译-rxjs介绍","date":"2017-01-22T13:26:40.000Z","path":"2017/01/22/rxjs翻译-rxjs介绍/","text":"介绍RxJS是一个基于可观察对象(Observable)序列，用于异步或者事件编程的库。它提供一个核心类型，Observable ，几个卫星类型（Observer, Schedulers, Subjects）以及一些由Array#extras (map, filter, reduce, every等)激发的，让异步事件可以以集合的方式被处理的运算子(Operators)。 可以将RxJS想象成是用于处理事件的Lodash. ReactiveX将Observer模式和Iterator模式和对集合进行函数式编程结合起来，从而满足了对事件序列进行管理的需求。 RxJS用于解决异步事件的管理问题，它的核心概念如下： Observable: 代表数据与事件的集合，这个集合可以被调用，从而可以生成数据和事件。 Observer: 回调函数的集合，用于获取想要数据。这些数据来自于Observable。 Subscription: 用于表示Observable的执行状态，主要用于执行的取消。 Operator: 函数式风格的纯函数，通过map, filter, concat, flatMap等操作对集合进行处理。 Subject: 与EventEmitter等价，唯一可以将一个值或者事件向个多个Observer进行广播的办法。 Schedulers: 一个中心化的、控制并发的分发器，允许我们可以在象setTimeout、requestAnimationFrame或者其它类似的计算中可以进行调整。 第一个例子通常你是这样注册事件的侦听器(listener)的。12var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log('Clicked!')); 使用RxJS的话，你要创建一个Observable来替换。 123var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .subscribe(() =&gt; console.log('Clicked!')); 纯粹(Purity)让RxJS强大的是它能完全通过函数来生成数值，这也就意味着可以减少代码出错的机会。 通常你会创建比较不纯粹的函数，在这样的函数里，其它的代码片段会让你的状态变的混乱。 123var count = 0;var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log(`Clicked $&#123;++count&#125; times`)); 而使用RxJS可以将你的状态进行隔离。 译者注： 指count不再需要定义在外面。 1234var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 这里scan运算子的工作方式与reduce在数组里的工作方式是一样的。它从传给回调函数的值中获取值。返回的值将会作为下一次的传入值。 译者注：scan第二个参数0是初始值。对于上面的函数来说就可以用来侦听被点击的次数了，非常的方便。 流转（Flow）RxJS有一堆的运算子可以帮助你控制事件如何在你的可观察对象里流转。 下面是你在纯JavaScript下允许一分钟最多一次点击的代码： 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', () =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(`Clicked $&#123;++count&#125; times`); lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 12345var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 其实的流转控制运算子还有filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged等。 值(Values)你可以转化赋给你的观察者的值。 下面是你在纯JavaScript下添加当前鼠标的每个点击事件的x轴位置的代码： 1234567891011var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', (event) =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; count += event.clientX; console.log(count) lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 123456var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .map(event =&gt; event.clientX) .scan((count, clientX) =&gt; count + clientX, 0) .subscribe(count =&gt; console.log(count)); 另外几个用于生成值的运算子有pluck, pairwise,sample等。 译者注：这里map可以将事件里的值取出来，如果不进行map，clientX里的值就是事件本身。这里要注意的是每次变换，其实对象是发生变化的。subscribe一次之后就不能再subscribe了。","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://baiwenhui.com/tags/rxjs/"}]},{"title":"《放弃F5，拥抱browser-sync》公众号文章错误说明","date":"2017-01-21T14:30:29.000Z","path":"2017/01/21/如何在技术上精进/","text":"首先说说声对不起，在上一篇的公众号文章：《放弃F5，拥抱browser-sync》中存在几个错误点。链接地址:http://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;tempkey=4s4RIGPKLlSI%2B%2B8VH3wx8KIrdHvnQSOEPLJ0k8joKaEA72cqJ41X6s0s0IzuDdKlkgLNIIrz1xkrL7lYcnIjCxGh6G%2BTC55MKR%2FWqW%2FbglQTt0aCB0A%2FFg4qN5SA%2B175n%2BIZz9ly%2BsRC5o4zHaD2Og%3D%3D&amp;chksm=1b4b2ba22c3ca2b41c5ffa577f24f378a13bd46665cd09a844d0b88bf733666a1900900694a8#rd，几个错误点修改如下： 文章中的：……更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试…将“进项调试”修改为“进行调试”2. 最后的代码有一个目录错误，因为我的粗心，给大家带来的不变，请见谅！在以后的文章中我会更加小心发表文章，力求保证没有错误！1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 修改为：1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;.app/dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;.app/dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 参照对比原文地址：http://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;tempkey=4s4RIGPKLlSI%2B%2B8VH3wx8KIrdHvnQSOEPLJ0k8joKaEA72cqJ41X6s0s0IzuDdKlkgLNIIrz1xkrL7lYcnIjCxGh6G%2BTC55MKR%2FWqW%2FbglQTt0aCB0A%2FFg4qN5SA%2B175n%2BIZz9ly%2BsRC5o4zHaD2Og%3D%3D&amp;chksm=1b4b2ba22c3ca2b41c5ffa577f24f378a13bd46665cd09a844d0b88bf733666a1900900694a8#rd 目前内容已经修改！欢迎反馈，欢迎交流：","tags":[]},{"title":"hexo搭建成功","date":"2017-01-19T15:20:52.000Z","path":"2017/01/19/hexo搭建成功/","text":"终于折腾完了，搭建好我的hexo，的确挺方便的！感谢前人的贡献！","tags":[]}]